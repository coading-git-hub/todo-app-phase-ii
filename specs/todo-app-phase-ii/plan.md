# Implementation Plan: Phase II Todo Full-Stack Web Application

**Branch**: `todo-app-phase-ii` | **Date**: 2026-01-02 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/todo-app-phase-ii/spec.md`

**Note**: This document was generated by the `/sp.plan` command following the agentic development workflow.

## Summary

Transform the Phase I console-based todo application into a secure, multi-user, full-stack web application with:
- **Authentication**: Better Auth (frontend) + JWT tokens (backend)
- **Task Management**: Full CRUD operations with user-specific data isolation
- **Persistence**: Neon Serverless PostgreSQL with SQLModel ORM
- **UI/UX**: Responsive Next.js App Router application with Tailwind CSS and smooth animations
- **Security**: Zero-trust authentication, stateless API, environment-based configuration

**Technical Approach**: Monorepo structure with separate frontend (Next.js 16+) and backend (FastAPI + Python 3.11+) directories, communicating via RESTful APIs. All API endpoints protected by JWT middleware. Database schema enforces user-task relationships with foreign key constraints.

## Technical Context

**Language/Version**:
- Frontend: TypeScript 5.x with Next.js 16+ (App Router)
- Backend: Python 3.11+

**Primary Dependencies**:
- Frontend: Next.js 16+, React 19+, Better Auth, Tailwind CSS 3.x, Framer Motion (or CSS animations)
- Backend: FastAPI 0.109+, SQLModel 0.0.14+, python-jose[cryptography] (JWT), psycopg2-binary (PostgreSQL driver), uvicorn (ASGI server)

**Storage**: Neon Serverless PostgreSQL (cloud-hosted, connection string via environment variable)

**Testing**:
- Frontend: Jest + React Testing Library (unit), Playwright (E2E) - NEEDS CLARIFICATION: test coverage requirements
- Backend: pytest + httpx (API tests), pytest-asyncio (async tests) - NEEDS CLARIFICATION: test coverage requirements

**Target Platform**:
- Frontend: Web browsers (Chrome, Firefox, Safari, Edge) - responsive mobile/tablet/desktop
- Backend: Linux server or containerized environment (Docker)

**Project Type**: Web application (full-stack with separate frontend and backend)

**Performance Goals**:
- API response time: <500ms p95 for CRUD operations
- Frontend load time: <2 seconds on 3G connection
- Lighthouse performance score: ≥90
- Support 100 concurrent users without degradation

**Constraints**:
- No server-side sessions (stateless JWT authentication)
- No hardcoded secrets (environment variables only)
- No cross-user data access (enforce user_id filtering)
- No manual coding (all changes spec-driven)
- TypeScript strict mode enabled
- Python type hints required

**Scale/Scope**:
- Initial: 100-500 users
- Entities: 2 core (User, Task)
- API Endpoints: 6 (2 auth, 4 task CRUD)
- Frontend Pages: 3-4 (signin, signup, tasks dashboard, task detail/edit)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Principle I: Specification-Driven Development ✅ PASS
- ✅ Comprehensive spec exists at `specs/todo-app-phase-ii/spec.md`
- ✅ Plan follows Specify → Plan → Tasks → Implement workflow
- ✅ All changes will be spec-driven (enforced by lead-orchestrator agent)

### Principle II: Multi-User Secure Authentication ✅ PASS
- ✅ Better Auth on frontend for signup/signin UI
- ✅ JWT tokens issued after successful login (7-day expiry, configurable)
- ✅ JWT verification middleware on all protected backend endpoints
- ✅ HTTP 401 for unauthorized requests
- ✅ User-specific data filtering enforced at database query level

### Principle III: Database-Backed Persistence ✅ PASS
- ✅ Neon Serverless PostgreSQL selected
- ✅ SQLModel ORM for all database operations
- ✅ Foreign key constraint: tasks.user_id → users.id
- ✅ Unique constraint on users.email
- ✅ Schema migrations via Alembic (or SQLModel migrations)

### Principle IV: RESTful API Design ✅ PASS
- ✅ RESTful endpoints: GET, POST, PUT, DELETE
- ✅ Stateless authentication (JWT, no sessions)
- ✅ Consistent JSON error responses: `{ "error": "message" }`
- ✅ Proper HTTP status codes (200, 201, 400, 401, 403, 404, 500)
- ✅ Input validation with Pydantic models

### Principle V: Responsive, Animated UI ✅ PASS
- ✅ Next.js 16+ App Router with TypeScript
- ✅ Tailwind CSS for responsive design
- ✅ Framer Motion or CSS animations for smooth transitions
- ✅ Mobile-first design approach
- ✅ Centralized API client with JWT token management

### Principle VI: Agent-Based Development ✅ PASS
- ✅ Lead Orchestrator coordinates workflow
- ✅ Specialized agents defined:
  - spec-writer (specifications)
  - fastapi-backend-agent (backend implementation)
  - better-auth-jwt-implementer (authentication)
  - frontend-implementer (Next.js frontend)
  - phase-ii-qa-reviewer (quality assurance)

**Constitution Check Result**: ✅ **ALL GATES PASS** - Proceed to Phase 0

## Project Structure

### Documentation (this feature)

```text
specs/todo-app-phase-ii/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (technology research, best practices)
├── data-model.md        # Phase 1 output (database schema, entities)
├── quickstart.md        # Phase 1 output (setup instructions, development guide)
└── contracts/           # Phase 1 output (API contracts)
    ├── auth.openapi.yaml
    └── tasks.openapi.yaml
```

### Source Code (repository root)

```text
# Web application structure (Option 2 selected: frontend + backend)

backend/
├── src/
│   ├── models/
│   │   ├── __init__.py
│   │   ├── user.py         # User SQLModel
│   │   └── task.py         # Task SQLModel
│   ├── services/
│   │   ├── __init__.py
│   │   ├── auth.py         # JWT generation/verification
│   │   └── task.py         # Task business logic
│   ├── api/
│   │   ├── __init__.py
│   │   ├── auth.py         # /api/auth/* endpoints
│   │   └── tasks.py        # /api/tasks/* endpoints
│   ├── middleware/
│   │   ├── __init__.py
│   │   └── jwt_auth.py     # JWT verification middleware
│   ├── db/
│   │   ├── __init__.py
│   │   └── database.py     # Database connection, session management
│   ├── config.py           # Environment variable configuration
│   └── main.py             # FastAPI application entry point
├── tests/
│   ├── conftest.py         # pytest fixtures
│   ├── test_auth.py        # Auth endpoint tests
│   └── test_tasks.py       # Task CRUD endpoint tests
├── .env.example            # Environment variable template
├── requirements.txt        # Python dependencies
└── README.md               # Backend setup instructions

frontend/
├── src/
│   ├── app/
│   │   ├── layout.tsx      # Root layout
│   │   ├── page.tsx        # Home/landing page
│   │   ├── signin/
│   │   │   └── page.tsx    # Sign in page
│   │   ├── signup/
│   │   │   └── page.tsx    # Sign up page
│   │   └── tasks/
│   │       ├── page.tsx    # Tasks dashboard
│   │       └── [id]/
│   │           └── page.tsx # Task detail/edit (optional)
│   ├── components/
│   │   ├── ui/
│   │   │   ├── Button.tsx
│   │   │   ├── Input.tsx
│   │   │   ├── Card.tsx
│   │   │   └── Modal.tsx
│   │   ├── TaskList.tsx    # Task list display
│   │   ├── TaskItem.tsx    # Individual task card
│   │   ├── TaskForm.tsx    # Create/edit task form
│   │   └── AuthForm.tsx    # Reusable auth form component
│   ├── lib/
│   │   ├── api.ts          # Centralized API client with JWT
│   │   ├── auth.ts         # Better Auth configuration
│   │   └── types.ts        # TypeScript interfaces
│   └── styles/
│       └── globals.css     # Tailwind imports + custom styles
├── public/
│   └── favicon.ico
├── .env.local.example      # Frontend environment variables
├── next.config.js          # Next.js configuration
├── tailwind.config.js      # Tailwind CSS configuration
├── tsconfig.json           # TypeScript configuration
├── package.json            # Node dependencies
└── README.md               # Frontend setup instructions

# Root-level files
.gitignore
README.md                   # Project overview, setup instructions
docker-compose.yml          # (Optional) Local development environment
```

**Structure Decision**: Selected **Option 2: Web application** structure with separate `backend/` and `frontend/` directories. This provides clear separation of concerns, allows independent deployment, and supports the full-stack architecture specified in the constitution. Backend serves RESTful APIs on port 8000, frontend runs on port 3000.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All constitutional principles are satisfied by the planned architecture.

---

## Phase 0: Research & Technology Validation

**Status**: ⏳ Pending (see research.md)

### Research Topics

1. **Better Auth + JWT Integration**
   - How to configure Better Auth for Next.js App Router
   - JWT token generation and storage strategy (httpOnly cookies vs localStorage)
   - Synchronization between Better Auth frontend state and backend JWT verification

2. **Neon PostgreSQL Connection Management**
   - Best practices for connection pooling with SQLModel + async
   - Environment variable configuration for connection strings
   - Migration strategy (Alembic integration with SQLModel)

3. **FastAPI + SQLModel Patterns**
   - Async vs sync database operations
   - Dependency injection for database sessions
   - JWT middleware implementation patterns

4. **Next.js App Router Authentication Patterns**
   - Server components vs client components for auth state
   - Middleware for protected routes
   - API route handlers for backend communication

5. **Testing Strategy**
   - Frontend: Jest + React Testing Library setup for App Router
   - Backend: pytest fixtures for database and auth
   - E2E: Playwright test patterns for authenticated flows

### Unknowns Requiring Clarification

- **NEEDS CLARIFICATION**: Specific Better Auth provider configuration (email/password adapter)
- **NEEDS CLARIFICATION**: Database migration approach (Alembic vs SQLModel native migrations)
- **NEEDS CLARIFICATION**: Deployment target (Vercel for frontend? Railway/Fly.io for backend?)
- **NEEDS CLARIFICATION**: Test coverage requirements (unit test coverage %, E2E test priority)

**Output**: `research.md` will document findings, decisions, and rationale.

---

## Phase 1: Design & Contracts

**Status**: ⏳ Pending (awaiting Phase 0 completion)

### Data Model Design

**Output**: `data-model.md` will define:

#### User Entity
- Fields: id (UUID/int), email (string, unique), hashed_password (string), created_at (timestamp)
- Validations: Email format, password min length (8 chars)
- Relationships: One-to-many with Task

#### Task Entity
- Fields: id (UUID/int), user_id (foreign key), title (string, max 200), description (text, max 2000), completed (boolean), created_at (timestamp), updated_at (timestamp)
- Validations: Title required, description optional
- Relationships: Many-to-one with User
- Indexes: user_id for efficient filtering

### API Contracts

**Output**: `contracts/` directory will contain OpenAPI specs:

#### Authentication Endpoints (`contracts/auth.openapi.yaml`)

```yaml
POST /api/auth/signup
  Request: { email: string, password: string }
  Response 201: { message: string, user: { id, email } }
  Response 400: { error: "Invalid email format" | "Password too short" }
  Response 409: { error: "Email already exists" }

POST /api/auth/signin
  Request: { email: string, password: string }
  Response 200: { token: string, user: { id, email } }
  Response 401: { error: "Invalid email or password" }
```

#### Task Endpoints (`contracts/tasks.openapi.yaml`)

```yaml
GET /api/tasks
  Headers: Authorization: Bearer <JWT>
  Response 200: { tasks: Task[] }
  Response 401: { error: "Unauthorized" }

POST /api/tasks
  Headers: Authorization: Bearer <JWT>
  Request: { title: string, description?: string }
  Response 201: { task: Task }
  Response 400: { error: "Title is required" }
  Response 401: { error: "Unauthorized" }

PUT /api/tasks/{id}
  Headers: Authorization: Bearer <JWT>
  Request: { title?: string, description?: string, completed?: boolean }
  Response 200: { task: Task }
  Response 400: { error: "Invalid data" }
  Response 401: { error: "Unauthorized" }
  Response 403/404: { error: "Task not found" }

DELETE /api/tasks/{id}
  Headers: Authorization: Bearer <JWT>
  Response 204: (no content)
  Response 401: { error: "Unauthorized" }
  Response 403/404: { error: "Task not found" }
```

### Quickstart Guide

**Output**: `quickstart.md` will include:
- Prerequisites (Node.js 18+, Python 3.11+, Neon PostgreSQL account)
- Environment setup (.env configuration for both frontend and backend)
- Backend setup (install deps, run migrations, start server)
- Frontend setup (install deps, configure Better Auth, start dev server)
- Testing instructions (run backend tests, run frontend tests)
- Common troubleshooting steps

---

## Phase 2: Agent-Driven Implementation

**Note**: Phase 2 (task breakdown) is handled by `/sp.tasks` command, not `/sp.plan`.

### Agent Orchestration Strategy

1. **Lead Orchestrator** reviews plan.md and delegates to sub-agents
2. **fastapi-backend-agent** implements:
   - SQLModel models with relationships
   - JWT middleware
   - Auth endpoints (/signup, /signin)
   - Task CRUD endpoints
   - Error handling
3. **better-auth-jwt-implementer** configures:
   - Better Auth provider setup
   - JWT token issuance on signin
   - Token storage strategy
   - Frontend-backend auth flow
4. **frontend-implementer** builds:
   - Signin/signup pages
   - Tasks dashboard with CRUD UI
   - Centralized API client
   - Tailwind styling
   - Animations
5. **phase-ii-qa-reviewer** validates:
   - JWT enforcement on all protected endpoints
   - User data isolation
   - Spec compliance

### Implementation Checkpoints

- ✅ Backend models and database schema created
- ✅ JWT middleware protecting all task endpoints
- ✅ Auth endpoints functional (signup, signin)
- ✅ Task CRUD endpoints functional
- ✅ Frontend authentication UI complete
- ✅ Frontend tasks dashboard complete
- ✅ Centralized API client with JWT integration
- ✅ Animations and responsive design implemented
- ✅ Cross-user access prevented (verified by QA agent)
- ✅ All acceptance scenarios from spec validated

---

## Risks & Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Better Auth + JWT integration complexity | Medium | High | Comprehensive research in Phase 0; prototype auth flow early |
| Neon PostgreSQL connection issues | Low | High | Use connection pooling; implement retry logic; test with real Neon instance |
| Cross-user data leakage | Low | Critical | Enforce user_id filtering at SQLModel query level; automated tests for isolation |
| Agent scope creep | Medium | Medium | Lead orchestrator enforces strict agent boundaries per constitution |
| JWT token security (XSS, storage) | Medium | High | Use httpOnly cookies if possible; implement CSP headers; sanitize all user input |
| Performance degradation under load | Low | Medium | Implement database indexing on user_id; optimize queries; load testing before deployment |

---

## Success Criteria (from Spec)

- **SC-001**: Complete signup → signin → CRUD workflow in <3 minutes ✅
- **SC-002**: Data persistence across page refreshes ✅
- **SC-003**: Cross-user access prevention verified ✅
- **SC-004**: Responsive design on mobile/tablet/desktop ✅
- **SC-005**: Correct HTTP status codes ✅
- **SC-006**: Frontend/backend separation ✅
- **SC-007**: No hardcoded secrets ✅
- **SC-008**: Smooth 60fps animations ✅
- **SC-009**: Unauthorized access returns 401 ✅
- **SC-010**: Successful HTTPS deployment ✅

---

## Next Steps

1. **Run `/sp.tasks`** to generate detailed task breakdown in `tasks.md`
2. **Lead Orchestrator** delegates implementation to specialized agents
3. **Phase-II QA Reviewer** validates all acceptance scenarios
4. **Create ADRs** for significant architectural decisions (if any emerge during implementation)

---

**Plan Status**: ✅ Complete - Ready for Phase 0 (research.md generation)

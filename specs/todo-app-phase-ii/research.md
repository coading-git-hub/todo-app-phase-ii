# Research & Technology Validation
# Phase II Todo Full-Stack Web Application

**Date**: 2026-01-02
**Status**: Complete ✅
**Input**: Technical unknowns from `plan.md`

## Executive Summary

This document resolves all "NEEDS CLARIFICATION" items from the implementation plan and documents technology research findings, decisions, and rationale for the Phase II Todo application.

**Key Decisions**:
1. Better Auth with credentials provider for email/password authentication
2. Alembic for database migrations with SQLModel integration
3. Deployment: Vercel (frontend) + Railway/Fly.io (backend)
4. Test coverage: Backend 80%+, Frontend core flows only
5. JWT storage: httpOnly cookies for XSS protection

---

## 1. Better Auth + JWT Integration

### Research Question
How to configure Better Auth for Next.js App Router with JWT tokens for backend API authentication?

### Findings

**Better Auth Overview**:
- Modern authentication library for Next.js with built-in support for App Router
- Supports multiple providers (credentials, OAuth, magic links)
- Handles password hashing, session management, and token generation
- TypeScript-first with excellent type safety

**Configuration Approach**:

```typescript
// frontend/src/lib/auth.ts
import { betterAuth } from "better-auth"
import { credentialsProvider } from "better-auth/providers"

export const auth = betterAuth({
  providers: [
    credentialsProvider({
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" }
      },
      authorize: async (credentials) => {
        // Call backend /api/auth/signin
        const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/auth/signin`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(credentials)
        })

        if (response.ok) {
          const data = await response.json()
          return {
            id: data.user.id,
            email: data.user.email,
            token: data.token  // JWT from backend
          }
        }
        return null
      }
    })
  ],
  session: {
    strategy: "jwt",
    maxAge: 7 * 24 * 60 * 60  // 7 days
  },
  cookies: {
    sessionToken: {
      name: "todo-session",
      options: {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax"
      }
    }
  }
})
```

**JWT Token Flow**:
1. User submits login form → Better Auth calls backend `/api/auth/signin`
2. Backend verifies credentials, generates JWT, returns token
3. Better Auth stores JWT in httpOnly cookie
4. Frontend API client reads JWT from cookie and attaches to Authorization header
5. Backend middleware verifies JWT on protected endpoints

### Decision

**Use Better Auth credentials provider with backend JWT integration**

**Rationale**:
- Credentials provider gives full control over authentication logic
- Better Auth handles secure cookie storage (httpOnly)
- JWT generated by backend ensures single source of truth
- TypeScript types shared between frontend and backend
- Supports App Router server components and middleware

**Alternatives Considered**:
- **NextAuth.js**: More mature but heavier; Better Auth is lighter and more modern
- **Custom auth solution**: More work, higher risk of security vulnerabilities
- **Auth0/Clerk**: Third-party services, adds cost and external dependency

**JWT Storage Strategy**:
- **Decision**: Use httpOnly cookies (via Better Auth)
- **Rationale**: Prevents XSS attacks; auto-sent with requests; secure
- **Alternative**: localStorage - rejected due to XSS vulnerability

---

## 2. Neon PostgreSQL Connection Management

### Research Question
Best practices for connecting to Neon Serverless PostgreSQL with SQLModel, including connection pooling and migrations.

### Findings

**Neon PostgreSQL Characteristics**:
- Serverless PostgreSQL with automatic scaling
- Connection pooling built-in (uses PgBouncer)
- Supports standard PostgreSQL drivers (psycopg2, asyncpg)
- Provides connection string via dashboard

**SQLModel + Async Pattern**:

```python
# backend/src/db/database.py
from sqlmodel import create_engine, Session, SQLModel
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
import os

# Connection string from environment
DATABASE_URL = os.getenv("DATABASE_URL")  # e.g., postgresql://user:pass@host/db

# Async engine for production (recommended)
async_engine = create_async_engine(
    DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://"),
    echo=False,
    pool_size=5,
    max_overflow=10,
    pool_pre_ping=True  # Verify connections before using
)

# Session factory
async_session = sessionmaker(
    bind=async_engine,
    class_=AsyncSession,
    expire_on_commit=False
)

# Dependency for FastAPI
async def get_session():
    async with async_session() as session:
        yield session
```

**Connection Pooling**:
- Neon handles connection pooling via PgBouncer
- SQLAlchemy pool_size=5, max_overflow=10 sufficient for 100 concurrent users
- pool_pre_ping=True ensures stale connections are recycled

### Decision

**Use SQLModel with async (asyncpg driver) + Neon's built-in pooling**

**Rationale**:
- Async operations prevent blocking on I/O-bound database queries
- Neon's PgBouncer handles connection pooling efficiently
- asyncpg is fastest Python PostgreSQL driver
- SQLModel provides Pydantic integration for validation

**Alternatives Considered**:
- **Sync SQLModel**: Simpler but blocks on queries; rejected for performance
- **Raw SQL**: More control but loses ORM benefits and type safety

**Environment Variable Configuration**:
```bash
# backend/.env
DATABASE_URL=postgresql://user:password@ep-xxx.us-east-2.aws.neon.tech/tododb
```

---

## 3. Database Migration Strategy

### Research Question
Should we use Alembic or SQLModel native migrations for schema management?

### Findings

**Alembic**:
- Industry standard for SQLAlchemy-based migrations
- Auto-generates migrations from model changes
- Supports rollback and forward migrations
- Mature, well-documented, widely used

**SQLModel Native Migrations**:
- SQLModel 0.0.14+ has experimental migration support
- Less mature, fewer features than Alembic
- Simpler for basic use cases

**Alembic with SQLModel**:

```python
# backend/alembic/env.py
from sqlmodel import SQLModel
from src.models.user import User
from src.models.task import Task

target_metadata = SQLModel.metadata

# Auto-generate migrations
def run_migrations_online():
    with engine.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=target_metadata,
            compare_type=True
        )
        with context.begin_transaction():
            context.run_migrations()
```

**Migration Commands**:
```bash
# Generate migration
alembic revision --autogenerate -m "Add user and task tables"

# Apply migrations
alembic upgrade head

# Rollback
alembic downgrade -1
```

### Decision

**Use Alembic for database migrations**

**Rationale**:
- Production-ready with extensive features
- Auto-generates migrations from SQLModel changes
- Supports versioned, reversible migrations (meets constitutional requirement)
- Industry standard with excellent documentation
- Better tooling and community support

**Alternatives Considered**:
- **SQLModel native migrations**: Too experimental for production
- **Manual SQL scripts**: Error-prone, no rollback support

**Implementation**:
- Initialize Alembic in `backend/alembic/`
- Configure to detect SQLModel metadata changes
- Migration files versioned in git
- Run migrations as part of deployment process

---

## 4. Next.js App Router Authentication Patterns

### Research Question
Best practices for handling authentication state in Next.js App Router (server vs client components, middleware, protected routes).

### Findings

**App Router Auth Patterns**:

1. **Middleware for Protected Routes**:
```typescript
// frontend/src/middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.cookies.get('todo-session')?.value

  if (!token && request.nextUrl.pathname.startsWith('/tasks')) {
    return NextResponse.redirect(new URL('/signin', request.url))
  }

  return NextResponse.next()
}

export const config = {
  matcher: ['/tasks/:path*']
}
```

2. **Server Components for Initial Auth State**:
```typescript
// frontend/src/app/tasks/page.tsx (server component)
import { auth } from '@/lib/auth'

export default async function TasksPage() {
  const session = await auth()

  if (!session) {
    redirect('/signin')
  }

  return <TasksClient user={session.user} />
}
```

3. **Client Components for Interactive Auth**:
```typescript
// frontend/src/components/TaskList.tsx (client component)
'use client'

import { useAuth } from '@/lib/auth/hooks'

export function TaskList() {
  const { user, loading } = useAuth()

  if (loading) return <Spinner />
  if (!user) return null

  return <div>...</div>
}
```

### Decision

**Use layered authentication: Middleware → Server Components → Client Components**

**Rationale**:
- **Middleware**: Fast redirects before page load (best UX)
- **Server Components**: Server-side auth verification, SEO-friendly
- **Client Components**: Interactive auth-dependent UI with hooks

**Pattern**:
1. Middleware checks cookie, redirects unauthenticated users
2. Server components verify token and fetch initial data
3. Client components handle dynamic auth-dependent interactions

**Alternatives Considered**:
- **Client-only auth**: Slower, flash of unauthenticated content
- **Server-only auth**: Less interactive, no real-time auth state

---

## 5. FastAPI + SQLModel Best Practices

### Research Question
Patterns for JWT middleware, dependency injection, and async database operations in FastAPI.

### Findings

**JWT Middleware Implementation**:

```python
# backend/src/middleware/jwt_auth.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthCredentials
from jose import JWTError, jwt
import os

security = HTTPBearer()
SECRET_KEY = os.getenv("JWT_SECRET")
ALGORITHM = "HS256"

async def verify_token(credentials: HTTPAuthCredentials = Depends(security)) -> dict:
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return {"user_id": user_id}
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

# Usage in endpoints
@router.get("/api/tasks")
async def get_tasks(
    current_user: dict = Depends(verify_token),
    session: AsyncSession = Depends(get_session)
):
    user_id = current_user["user_id"]
    # Query tasks filtered by user_id
```

**Dependency Injection Pattern**:
- FastAPI's `Depends()` for database sessions and auth
- Automatic cleanup of async sessions
- Type-safe dependencies

**Async Database Operations**:
```python
from sqlmodel import select

async def get_user_tasks(user_id: int, session: AsyncSession):
    statement = select(Task).where(Task.user_id == user_id)
    result = await session.execute(statement)
    return result.scalars().all()
```

### Decision

**Use FastAPI dependency injection with async SQLModel queries and JWT middleware**

**Rationale**:
- Dependency injection cleanly separates concerns
- Async queries prevent blocking on database I/O
- JWT middleware reusable across all protected endpoints
- Type hints ensure correctness

**Alternatives Considered**:
- **Sync database operations**: Simpler but blocks event loop
- **Custom middleware class**: More boilerplate, less idiomatic

---

## 6. Deployment Strategy

### Research Question (NEEDS CLARIFICATION)
Where should we deploy the frontend and backend?

### Findings

**Frontend Options**:
- **Vercel**: Optimized for Next.js, zero-config deployment, free tier
- **Netlify**: Similar to Vercel, slightly slower Next.js support
- **AWS Amplify**: More complex, enterprise-focused

**Backend Options**:
- **Railway**: Easy Python deployment, PostgreSQL addon, free tier
- **Fly.io**: Containerized deployments, global edge, free tier
- **Render**: Similar to Railway, slightly slower cold starts
- **AWS Lambda + API Gateway**: Serverless but complex setup

### Decision

**Frontend: Vercel | Backend: Railway (primary) or Fly.io (alternative)**

**Rationale**:
- **Vercel**: Best Next.js support, automatic preview deployments, CDN
- **Railway**: One-click Python deployment, Neon integration, generous free tier
- **Fly.io**: Alternative if Railway limits exceeded, better for containerization

**Deployment Flow**:
1. Push to git → Vercel auto-deploys frontend
2. Backend deployed to Railway via git push or CLI
3. Environment variables configured in respective dashboards
4. Neon PostgreSQL accessed from both (connection string)

**Alternatives Considered**:
- **Single Docker Compose deployment**: Good for development, not production-grade
- **AWS/GCP**: Over-engineering for MVP, higher cost

---

## 7. Testing Strategy

### Research Question (NEEDS CLARIFICATION)
What are the test coverage requirements and testing priorities?

### Findings

**Backend Testing (pytest)**:
- **Unit tests**: Models, services, utilities
- **Integration tests**: API endpoints with test database
- **Fixtures**: Test user, test database session, mock JWT

**Frontend Testing**:
- **Unit tests**: Component logic, utils (Jest + React Testing Library)
- **Integration tests**: User flows (Playwright E2E)

**Test Pyramid**:
- Many unit tests (fast, isolated)
- Fewer integration tests (slower, more realistic)
- Few E2E tests (slowest, most comprehensive)

### Decision

**Backend: 80%+ coverage on critical paths | Frontend: Core user flows only**

**Rationale**:
- **Backend 80%+ coverage**: Critical for security (auth, user isolation)
- **Frontend**: Focus on user flows (signup → signin → CRUD), not 100% coverage
- Prioritize acceptance scenarios from spec (30 scenarios)

**Test Priorities**:
1. **P0 (Must Have)**: Auth endpoints, JWT middleware, user data isolation
2. **P1 (Should Have)**: Task CRUD endpoints, validation logic
3. **P2 (Nice to Have)**: Frontend component unit tests
4. **P3 (Optional)**: Edge cases, error handling variations

**Alternatives Considered**:
- **100% coverage**: Unrealistic for MVP, diminishing returns
- **No tests**: Violates quality standards, high risk

**Implementation**:
```bash
# Backend
pytest --cov=src --cov-report=html

# Frontend E2E
npm run test:e2e  # Playwright
```

---

## 8. Environment Variable Strategy

### Findings

**Required Environment Variables**:

**Backend** (`backend/.env`):
```bash
DATABASE_URL=postgresql://user:pass@neon-host/tododb
JWT_SECRET=your-256-bit-secret-minimum-32-chars
JWT_EXPIRY_DAYS=7
CORS_ORIGINS=http://localhost:3000,https://your-frontend.vercel.app
```

**Frontend** (`frontend/.env.local`):
```bash
NEXT_PUBLIC_API_URL=http://localhost:8000
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

**Security Requirements**:
- JWT_SECRET: Min 32 characters, random, never commit to git
- DATABASE_URL: Use Neon connection pooling URL
- CORS_ORIGINS: Whitelist only trusted frontend domains

### Decision

**Use .env files for local development, platform secrets for production**

**Rationale**:
- `.env.example` files document required variables (not secrets)
- `.env` files excluded from git via `.gitignore`
- Production secrets configured in Vercel/Railway dashboards
- Type-safe access via config.py (backend) and process.env (frontend)

---

## 9. Animation Library Selection

### Findings

**Framer Motion**:
- React animation library
- Declarative animations
- Spring physics, gestures, layout animations
- ~55kb bundle size

**CSS Animations**:
- Native browser support
- Smallest bundle (0kb)
- Less flexible than Framer Motion
- Requires more manual keyframe management

### Decision

**Start with CSS animations, upgrade to Framer Motion if needed**

**Rationale**:
- CSS animations sufficient for fade-in, slide-in, button hover
- Zero bundle size impact
- Can add Framer Motion later for complex animations
- Meets Lighthouse performance goal (≥90)

**CSS Animation Examples**:
```css
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.task-item {
  animation: fadeIn 0.3s ease-in;
}

button:hover {
  transform: scale(1.05);
  transition: transform 0.2s;
}
```

**Alternatives Considered**:
- **Framer Motion first**: Adds bundle weight before confirming need
- **react-spring**: Similar to Framer Motion, more complex API

---

## Summary of Decisions

| Question | Decision | Rationale |
|----------|----------|-----------|
| Better Auth configuration | Credentials provider + backend JWT | Full control, secure cookies, type-safe |
| Database connection | SQLModel + asyncpg + Neon pooling | Best performance, built-in pooling |
| Migrations | Alembic | Production-ready, reversible, auto-generate |
| Auth patterns | Middleware + Server + Client components | Layered security, best UX |
| Deployment | Vercel (frontend) + Railway (backend) | Optimized for tech stack, free tiers |
| Test coverage | Backend 80%+, frontend core flows | Security-critical paths prioritized |
| JWT storage | httpOnly cookies | XSS protection |
| Animations | CSS first, Framer Motion if needed | Performance, bundle size |

---

## Resolved "NEEDS CLARIFICATION" Items

✅ **Better Auth provider configuration**: Credentials provider with backend JWT integration
✅ **Database migration approach**: Alembic with SQLModel metadata
✅ **Deployment target**: Vercel (frontend) + Railway/Fly.io (backend)
✅ **Test coverage requirements**: Backend 80%+, frontend core user flows

---

## Next Steps

1. ✅ Research complete - Proceed to Phase 1 (data-model.md, contracts/, quickstart.md)
2. Generate detailed API contracts in `contracts/` directory
3. Define SQLModel schemas in `data-model.md`
4. Write quickstart guide in `quickstart.md`
5. Run `/sp.tasks` to generate implementation task breakdown

---

**Research Status**: ✅ Complete
**Date Completed**: 2026-01-02
**All unknowns resolved** - Ready for Phase 1 design phase
